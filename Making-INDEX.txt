[0. 법칙들 ]=============================================

0. [블로그를 운영한다?] => [데이터베이스에 연결할 필요가 없다] => [내 로컬 컴퓨터에 파일 시스템을 사용하면 되지!] => [MarkDown 언어가 유용해짐]

1. Page 들은, 간단하게, [복잡한 것들, 스타일링 한 것들] 전부 component 에서 떼오도록!


[0. TIP 들 ] =============================================

1. Html 에서, css 변수 (--main-font-size : ...) 를 사용했던 것 처럼,
    "globals.css" 에 "css 변수" 를 넣어서, 여기저기 사용 가능하다.

2. 이미지의 사용 [ next/image **]
    import Image from "next/image"
    < Image src={"/src/posts/IMG_5584.JPG"} alt="myImage" width={300} height={300}/>

    ** https://nextjs.org/docs/api-reference/next/legacy/image#layout 에 가면 더 자세히

    ** 특히 "layout 속성"이 기가막힌다.

3. Link from "next/link" 를 사용할때,[ 스타일링시, a 태그로 스타일링] 하면, [Link 는 사실 내부적으로 a로 쓰이기 때문에, 스타일링이 된다.]

4. [imagePath 지정하기] Image 를 추가할 때, "iamge 이름" 과 "image 특정경로(slug)" 를, "DB에 저장하고 받아온 후에"

    image = "zxxx.img"
    slug = "src/post/..."

    imagePath = `/images/posts/${slug}/${image}`

    이런식으로 저장하고 사용하면 깔끔하다

    아니면, 평소처럼, "상대경로로 저장하는것"도 좋다.

5. slug 란 "중요 단어 들을 잘 섞어서 만든 제목" 정도로 해석 가능하다. 예로, "getting-started-with-nextjs" 같이 문장형식을 띈다.

6. id 대신, slug 를 사용해도 좋다. 

7. MarkDown 의 사용

    /MarkDown.txt 참조
    https://www.npmjs.com/package/react-markdown

8. gray matter 의 사용 : MARKDOWN 에서 META-DATA 와 CONTENT 를 분리시키는 패키지

    https://www.npmjs.com/package/gray-matter

9. 무언가를 변수로 뽑았을때, 변수 위에 마우스를 갖다 대면, 어떤 형태인지 알려준다.

10. 정렬하기 2 
    const sortedPosts =  allPosts.sort((postA,postB)=>(postA.date>postB.date ? -1 : 1)) 

11. .replace 사용법

const postName = filename.replace(/\.md$/, "");         
// 확장자명 없애기   / / => 시작, 끝,    \ => 여기부터   .md => 이것을     $ => 뒤로부터


12. import 할때 이름 바꾸기 "as"로
    import { XXX as MScustom} from "react"

    ==> MScustom 으로 메서드이름이 변경됌

-   ************* 13. 컴포넌트 안에서, "컴포넌트 함수 안"에 "만든 새로운 함수"(정말 함수의 용도인) 에서는, fetch 사용할때, async await 를 사용해도 된다!!!!



[0. 코딩 시작 ]=============================================

1. 페이지 구축하기
    : 전반적으로 페이지를 구축한다.

    1) 시작페이지 (환영 + 중요한 몇개의 블로그 게시물)
    2) Contact 페이지 - 댓글기능, 컨택기능
    3) 전체 글 페이지
    4) 디테일 글 페이지 - 댓글기능

2. Layout 구축하여, header 처럼 전반적인 ui를 짜줌

3. HomePage 작업시작 [ Welcome component, Feacture component] 

//  1) Welcome section
//  2) Feacture Posts

4. Welcome component

    1) Image from next/image 로 이미지 생성
    2) 스타일 생성
        * 이미지 파일은 반드시 public 폴더에 넣어야 한다.

5. Feacture component 

    1) getStaticProps 로 사전 데이터 페칭 하는 것이 좋아보임 [중요한 포스트들만 모은 것들이니]
    2) post를 화면에 표시하는 방식을 전부 "통일" 하기 위하여," post-card(item)" 과 "post-grid(list)" 를 만들어서, 화면에 표시하는 것이 좋겠다.


    3) "기본 틀 잡기 with dummyData"

    ==== <HomePage>===================================================================

            import Welcome from "../components/homepage-components/welcome";
            import FeacturePosts from "../components/homepage-components/feature-post";

            function HomePage(props) {
-               const { dummyData } = props;
                return (
                    <div>
                    <div>
                        <Welcome />
-                       <FeacturePosts posts={dummyData} />
                    </div>
                    </div>
                );
                }

-           export async function getStaticProps() {
                const dummyData = [{ title: "ms" }, { title: "js" }];
                return {
-                   props: { dummyData },
                };
            }

            export default HomePage;

    ==== < FeacturePosts > ===================================================================

            import styles from "./feature-post.module.css";
            import PostGrid from "../posts/post-grid";
            import { Fragment } from "react";

            function FeacturePosts(props) {
-               const { posts } = props;
                return (
                    <Fragment>
-                       <PostGrid posts={posts} />
                    </Fragment>
                );
            }
            export default FeacturePosts;

    ==== <Post Grid>===================================================================

            import styles from "./post-grid.module.css";
            import PostItem from "../posts/post-item";
            
            function PostGrid(props) {
-               const { posts } = props;
                return (
                    <ul>
-                   {posts.map((post) => (
                        <li key={post.id}>
-                          <PostItem posts={post} />
                        </li>
-                   ))}
                    </ul>
                );
                }
            
            export default PostGrid;
        
    ==== <Post Item> ===================================================================

            import Link from "next/link";
            import Image from "next/image";
            import styles from "./post-item.module.css";
            
            function PostItem(props) {
-             const { image, title ,id} = props.posts;

              return (
-               <Link href={"/posts/" + id}>
                  <div>
-                   <Image src={image} alt={"image"} width={300} height={300} />
                  </div>
                  <div>
-                   <h2> {title} </h2>
                    <p> description </p>
                  </div>
-               </Link>
              );
            }
            export default PostItem;

6. Feature component 데이터 정리 및 마무리

    <Hompage>
        export async function getStaticProps() {
            const dummyData = [
            {
                title: "ms",
                    ...
            {
                title: "ks",
                image: "/src/posts/IMG_5584.JPG",
                id: "e4",
                date: "2021-03-12",
                description: "this is des",
            },
            ];
            return {
            props: { dummyData },
            };
        }

    < Itmes >   
        : Image의 layout 속성을 사용해 보았다.
        : 기타 다른 데이터도 뽑아서 더미를 넣어놓았다

    ==========================================================================================
        function PostItem(props) {
            const { image, title, id, description, date } = props.posts;
        
            const reformDate = new Date(date).toLocaleString("ko-KR");
        
            return (
            <Link href={"/posts/" + id}>
                <div>
                <div className={styles.image}>
                    <Image
-                   src={image} alt={"image"} width={300} height={200} layout="responsive"/>
                </div>
                <div className={styles.content}>
                    <h3> {title} </h3>
                    <time> {reformDate}</time>
                    <p> {description} </p>
                </div>
                </div>
            </Link>
            );
        }
        export default PostItem;

7. Allpost Page 더미 작업시작 ( with post-grid 재사용 , dummyData 사용, 껍데기만 완료)

    <Allpost component>

            import styles from "./all-posts.module.css";
            import { Fragment } from "react";
            import PostGrid from "../../components/posts/post-grid";

            function AllPosts(props) {
            const { posts } = props;

                return (
                    <Fragment>
                        <h1> All posts</h1>
                        <PostGrid posts={posts} />
                    </Fragment>
                );
            }

            export default AllPosts;

    <Allpost Page>

            import AllPosts from "../../components/posts/all-posts";

            const dummyData = [
            {
                title: "ms",
                    ...

                image: "/src/posts/IMG_5584.JPG",
                id: "e4",
                date: "2021-03-12",
                description: "this is des",
            },
            ];

            function AllPostsPage() {
                return (
                    <div>
                        <div>
-                           <AllPosts posts={dummyData} />
                        </div>
                    </div>
                );
            }
            export default AllPostsPage;



8. Detail Page 더미 작업시작 With Markdown{ "[postid].js" 동적 페이지} + Markdown + dummyData

        "post component 폴더" 에, "post-detail 폴더를 만들고", 
        그 안에, "post-header.js" 와 "post-content.js" 를 만들어 작업 시작

        ==> "post-header 가 포함된 post-content" 를, "Page 에 넣을 예정"


    <Markdown 이란?>
        : "HTML" 및 "JSX" 코드로 변경시킬 수 있는 "TEXT 기반 컨텐츠"
-           StackOverFlow 사이트에서, 글을 작성할 때를 기억하자

    <Markdown 의 장점>
        1. 간결하다.
        2. 별도의 도구없이 작성가능하다.
        3. 다양한 형태로 변환이 가능하다.
        4. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다.
        5. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
        6. 지원하는 프로그램과 플랫폼이 다양하다.

    <왜 블로그를 만들때, Markdown 을 사용하는가?>
        : 앞서 말한 장점들 덕분에, blog post에서, content 를 작성할때, 간편하고, 깔끔한 "텍스트"로, 작성 후
            JSX 코드로 변환시켜, 렌더링을 할 수 있기 때문

        : 만약, 블로그 글을 작성하는데, "HTML 코드"로 전부 글을 작성한다면,
            한줄 한줄마다, p 태그로 묶어주랴, h1 태그로 묶어주랴, 띄어쓸때, nbsp 쓰고, br 쓰고, /n 쓰고 아주 가독성이 좋지 못할 것이다.
            

    <Markdown 사용법>
        :https://gist.github.com/ihoneymon/652be052a0727ad59601

-   <Markdown 을 JSX 코드로 변환시켜, 렌더링되게 하기>

        1. Content 에 "간편한 Mark-down 언어" 로, 작성 한다.
        2. "react-markdown" 패키지를 install 한 후,     //  import ReactMarkdown from "react-markdown"  // 으로 import 한다
            https://www.npmjs.com/package/react-markdown

        3. ReactMarkdown 태그로 감싼 후, content 를 렌더링한다.

            <ReactMarkdown> {dummyData.content} </ReactMarkdown>

        4. 짜잔- markdown 언어가 JSX 로 바뀌어, 렌더링 된다.

    < [postid] Page >
-       : "MarkDown 언어를 사용하여, content 에 코드를 넣어보았다"

            import PostContent from "../../components/posts/post-detail/post-content";

            const dummyData = {
                title: "js",
                image: "/src/posts/IMG_5584.JPG",
                id: "e2",
                date: "2020-11-08",
                description: "this is des",
-               content: "# title",
            };
            
            function PostDetailPage() {
            return (
                <div>
                    <PostContent posts={dummyData} />
                </div>
            );
            }
            
            export default PostDetailPage;

    < post Content Component >
-       : MarkDown 언어로 온, 코드를, JSX 로 해석해서, 사용하게 만들어주는, ReactMarkdown 패키지를 사용했다.

            import PostHeader from "./post-header";
-           import ReactMarkdown from "react-markdown";

            function PostContent(props) {
                const { posts } = props;
                return (
                    <article>
                        <PostHeader posts={posts} />
-                       <ReactMarkdown> {posts.content} </ReactMarkdown>
                    </article>
                );
            }

            export default PostContent;

    < post Header Component >

            import Image from "next/image";

            function PostHeader(props) {
            const { title, image } = props.posts;
                return (
                    <header>
                        <h1> {title} </h1>
                        <Image src={image} alt="post" width={300} height={300} />
                    </header>
                );
            }

            export default PostHeader;

9. 모든 페이지의 기본 틀 잡기 완료. [이제 실제 데이터를 저장하고, 불러오는 작업 시작]

10. MarkDown 파일 생성 & 작성," MarkDown에 이미지 소스를 넣기 위해", [이미지가 들어있는 폴더 이름]을 [MarkDown 파일이름과 동일하게 설정]

-   < data - posts - "getting-start-with-nextjs.md" >

            ---
            title: "Getting start with Next JS"
            date: "2022-10-15"
            author: "ms"
            image: \src\posts\getting-start-with-nextjs\IMG_5584.JPG
            description: description
            isFeatured: true
            ---

            # This is a title

            This is Some regular TEXT [link](https://google.com)
    
-   < src/ posts / getting-start-with-nextjs / IMG_5584.JPG>
        로, 이미지 들어있는 폴더이름 변경

-   ***  markdown 의 파일이름과 동일한 폴더이름이 있어야, markdown 이 이미지를 인식 할 수 잇음. "아직 이해 안감"



11. 이후, fs를 사용하는 helper 함수를 아웃소싱하여, [AllPosts 페이지와, homepage 의 FeatruePost 채워넣기]

    <프로세스>
            1) "fs" 에 접근, "readdirSync" 를 통해, "data/posts 안에 있는 모든 파일의 이름을 확인"

            2) "fs"에 접근, "readFileSync" 를 통해, 개별 파일의 컨텐츠를 가져와
                파일이름, 파일내용, 파일 metadata 를  "gray-matter 패키지" 를 통해, 분리, 사용 하는 "함수를 생성"

            3) 앞서 "readdirSync" 를 통해 얻은 모든 파일 이름을 가지고, "for문을 돌려, readFileSync 함수에 넣어", "모든 파일을 읽는 함수를 생성"

            4) isFeatured 를 따로 뽑아내는 함수를 생성

    < 코드 >

-       ** DB를 사용하지 않을것이기 때문에, filename 이 곧, postid 가 될것이다.

    ==== <helper - post-uitl.js> ==============================================================================

            import fs from "fs";
            import path from "path";
            import matter from "gray-matter";

            const postsDirPath = path.join(process.cwd(), "data", "posts");

-           export function getSinglePost(filename) {
                const filePath = path.join(postsDirPath, filename);     // 단일 파일을 가져오기 위한 fs
                const singlePost = fs.readFileSync(filePath, "utf-8");  // 모든 유니코드 문자 지원을 위한 utf-8 인코딩
                const { data, content } = matter(singlePost);           // matter 로 나온 객체를  각 변수로 나누어 만들어주고

                const postName = filename.replace(/\.md$/, "");         // 확장자명 없애기   / / => 시작, 끝,    \ => 여기부터   .md => 이것을     $ => 뒤로부터

                const postData = {
                    postid: postName,
                    ...data,
                    content: content,
                };
                return postData;
            }

-           export function getAllPosts() {
                const allFiles = fs.readdirSync(postsDirPath);          // 전체 파일 갯수를 위한 [폴더 안의 모든 파일 뒤지기]

                const allPosts = allFiles.map((filename) => getSinglePost(filename));       // map을 통해, "파일이름의 배열을 넣어" "데이터 객체로된 배열을 만듬"

                const sortedPosts =  allPosts.sort((postA,postB)=>(postA.date>postB.date ? -1 : 1))     // 정렬

                return sortedPosts;
            }

-           export function getFeaturedPost() {                         
                const feadturedPosts = getAllPosts().filter((post) => post.isFeatured);     // Freatured post 들 뽑아내기
                return feadturedPosts;
            }
        
    ============================================================================================================================================================

    ======    < pages- posts - index.js> ========================================================================

            import AllPosts from "../../components/posts/all-posts";
-           import { getAllPosts } from "../../helper/post-util";

            function AllPostsPage(props) {

                const {posts} = props
                return (
                    <div>
                        <div>
                            <AllPosts posts={posts} />
                        </div>
                    </div>
                );
            }

            export function getStaticProps() {
                
-               const allPosts = getAllPosts();

                return {
                    props: {
                        posts: allPosts,
                    },
                };
            }

            export default AllPostsPage;

    ======    <pages - index> ========================================================================

            import AllPosts from "../../components/posts/all-posts";
-           import { getAllPosts } from "../../helper/post-util";

            function AllPostsPage(props) {
                const { posts } = props;
                return (
                    <div>
                    <div>
                        <AllPosts posts={posts} />
                    </div>
                    </div>
                );
            }
        
            export async function getStaticProps() {
-               const featuredPosts = getFeaturedPost();
            
                return {
                    props: {
-                       posts: featuredPosts,
                    },
                };
            }
            
            export default HomePage;

    < 주의할점 >

        1. "fs" 는, "서버측 코드에서만 접근 가능"하다
            그렇다는 것은 "fs" 로 만든 파일을 불러오기 위해서는,
            "getStaticProps" 나, "getServerSideProps" 혹은 "API 를 만든후, 요청후에, fetch" 로 불러와야 한다는 말이다.

        2. 굳이 필요없는 API 를 만들 필요는 없으니 "getStaticProps" 로 작업하도록 한다.
        

12. 동적 경로(Detail Page)에, 동적 값 집어넣기

    : "HomePage의 FeaturePosts" 와는 달리, "Detail Page" 는 [동적 경로이다.]
    
        => "singlePost 를 불러오는 helper 함수를 동적으로 만들어보자"

    
        <프로세스>
            Allpost ==> 글 클릭 ==> posts/postid(filename) 페이지로 이동함
            ==> context.params 로 postid를 페이지에서 뽑아, 그에 맞는 singlePost 만 가져올 것
    
        <문제점>
            기존의 helper 함수는, 

    -           export function getSinglePost(filename) {
    -               const filePath = path.join(postsDirPath, filename);
                    const singlePost = fs.readFileSync(filePath, "utf-8");
                    const { data, content } = matter(singlePost);

            "filename" 으로 "확장자가 없는 파일명을 넣으면(.ms)", fs에 접근해 파일을 읽은 수 없으므로,


        [수정] <helper -  post-util.js  >

-               export function getSinglePost(fileID) {
                    const postName = fileID.replace(/\.md$/, "");
                    const filePath = path.join(postsDirPath, `${postName}.md`);
                    const singlePost = fs.readFileSync(filePath, "utf-8"); 
                    const { data, content } = matter(singlePost);
                
                    const postData = {
                    postid: postName,
                    ...data,
                    content: content,
                    };
                    return postData;
                }

            ==> fileID 에, ".md 가 있던 없던", "filePath 로는 .md를 붙여, 확장자가 있께 만들고"
            ==> fileID 에, ".md 가 있던 없던"," postid로 가는 이름에는 .md 를 떼어내고 보낸다."
                
            
    <코드>
            
        <helper -  post-util.js  >
-           :모든 파일을 다 가져와서, postid 를 뽑는 무식한 짓을 하지 말고, 새로운 helper 함수를 통해, filename(postid) 만 뽑는 함수를 만들자.
            
-           export function getAllPostId() {
                 return fs.readdirSync(postsDirPath).map((filename) => filename.replace(/\.md$/, ""));
            }

        < [postid].js >
-           : context.params.postid 로 동적 값을 뽑아서, 적절한 single 포스트를 가져오고
            : Paths 는 따로 만들어놓은 함수를 사용해, 넣어준다.


            import PostContent from "../../components/posts/post-detail/post-content";
            import { getAllPostId, getSinglePost } from "../../helper/post-util";
            
            function PostDetailPage(props) {
            const { postData } = props;
            return (
                <div>
-                   <PostContent posts={postData} />
                </div>
            );
            }
        
            export async function getStaticProps(context) {
-               const { postid } = context.params;
                
-               const fileData = getSinglePost(postid);
                
                return {
                    props: {
-                       postData: fileData,
                    },
            -       revalidate: 500,    // 파일 내부의 값 하나 고치고자, 전체를 리빌딩, 재배포 할 수 없으므로, 편하게 revalidate 속성을 넣어줌
                };
            }
            
            export async function getStaticPaths() {
            
                const allFileData = getAllPostId();
                
                const paramsData = allFileData.map((filedata) => ({
                    params: { postid: filedata },
                }));
                
                return {
                    paths: paramsData,
-                   fallback: false, 
                };
            }

            export default PostDetailPage;

-       ==> fallback 정하기
                :  모든 게시물을 전부, 사전 렌더링 시켰으므로, "false" 도 적합
                    "블로그 글이 수천개씩 되면" "blocking" 나, "몇개만 사전 렌더링 하고 true"로 하는 것도 좋겠다. 모든 글을 다 누르지는 않을테니
            
13. Next Image 컴포넌트를 통해, 마크다운으로부터, 이미지 렌더링하기 + 이미지 오버라이드
    : 갑분 마크다운. "마크다운에 코드와 이미지를 넣고싶다."
    : 넣을 수는 있다. "문제는 렌더링을 할 시에 문제가 발생한다."

    <프로세스>
        .md(markdown) 로 파일작성 => gray-matter 로 객체화 => 
            객체 데이터를 PostContent 로 넣고 => ReactMarkdown 으로 해석시켜서 화면에 표시

        * md 파일이름과 img 파일 폴더 이름이 동일하게 만들어서, OK 화면에 표시까지 딱 되었다!

    <문제점>
        ** 이미지가 Next.js 에 적합한 이미지가 아닌, "원본 이미지" 이다.
            => "이미지 크기 바꾸기도 힘들고, lazy rendering 될리가 없고, 원본파일 크기 그대로 가져온다."

    <해결>
        ReactMarkdown 에는, "components" 라는 메서드가 존재한다.
           이 "components" 에 "내가 설정한 custom Components 설정"을 만들어, 
            실제 들어가는 파일의 설정을 nextjs의 Image로 "오버라이드(덮어씌운다)"시킨다.


    <코드> 
    <component - post-detail - post-content>

        import PostHeader from "./post-header";
        import ReactMarkdown from "react-markdown";
        import styles from "./post-content.module.css";
        import Image from "next/image";

        function PostContent(props) {
        const { posts } = props;

-       const myComponents = {
-           img(image) {
-             return (<Image src={`/src/posts/${posts.postid}/${image.src}`} alt={image.alt} width={300} height={300} />);
            },
          };

        return (
            <article className={styles.content}>
                <PostHeader posts={posts} />
-               <ReactMarkdown components={myComponents}>{posts.content}</ReactMarkdown>
            </article>
        );
        }

        export default PostContent;

    <해석>
        REACT-MARKDOWN DOCS : https://github.com/remarkjs/react-markdown#appendix-b-components

        myComponents 라는 "이미지를 오버라이드 할 components" 를 만든 후에,
        "react-markdown" 에서 제시하는 설정들을 활용해, 설정을 만든다.

            img(image){
                return <Image src={`/src/posts/${posts.postid}/${image.src}`} alt={image.alt} width={300} height={300} />
            }
            
        "img" 는, 마크다운 이미지를 지칭 (DOCS 어렴풋 나와있음)
        "image" 파라미터는 임의로 적어도 되고
        "image.src" 는 내가 markdown 파일에 적은 곳의 "src"
        "image.alt" 는 내가 markdown 파일에 적은 곳의 "alt"
            
            *참조 : markdown 의 이미지 표시 기법
            
                ![ alt ]( src )
                ![Create routes via your file + folder structure](IMG_5584.JPG)

        ==> 동적인 경로로, 마크다운파일에, 파일이름만 적으면, 자동으로 src를 맞춰주게 코드를 짠 것이다.
    

14. "마크다운 코드 사용" 및 "코드 오버라이드" WITH "react-syntax-highlighter" 패키지

        import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
        import { dark } from "react-syntax-highlighter/dist/cjs/styles/prism";

        function PostContent(props) {
            const { posts } = props;

            const myComponents = {
                code(code) {
                    return ( <SyntaxHighlighter language={code.language} style={dark} children={code.children} /> );
                },
            };

            return (
                <article className={styles.content}>
                    <PostHeader posts={posts} />
-                   <ReactMarkdown components={myComponents}>{posts.content}</ReactMarkdown>
                </article>
        );

            **  "code.children" 은     
                    ```.js               
                    ```
                사이에 있는 코드들을 가리키며

                "code.language" 는, ".js" 니까 "javascript" 로 표기될것이다.

15. API 사용하여 Contact 페이지 작업하기

    : contact 페이지 만들고, api 만들고, mongodb 연결까지

    
15-1. "submit 버튼 눌렀을때, 값이 다 지워지려면,"
        "useState" 를 사용하여, "input 안에 value 값을 설정 한 다음"에, "버튼 눌렀을때, value 가 바뀌도록 해야한다."

16. Context 를 사용하여 , [데이터를 보낼때, footer 에 나오는 UI 를 만들어보자]

    1. notification Component 만들기

    ====================== <ui- notification.js>========================================================================================

            import styles from "./notification.module.css";
            import { useContext } from "react";
            import NotificationContext from "../../store/contact-context";
            
            function Notification() {
                const NotificationCtx = useContext(NotificationContext);
                const activeNotification = NotificationCtx.notificationData;
                let status = activeNotification.status;
                let statusStyle = "";
                
                function hideNoti() {
                    NotificationCtx.hideNotification();
                }
                
                if (status === "pending") {
                    statusStyle = styles.pending;
                }
                if (status === "success") {
                    statusStyle = styles.success;
                }
                if (status === "error") {
                    statusStyle = styles.error;
                }
                
                return (
                    <div className={styles.notification} onClick={hideNoti}>
                        <ul className={statusStyle}>
                            <li>{activeNotification.title}</li>
                            <li>{activeNotification.message}</li>
                            <li>{activeNotification.status}</li>
                        </ul>
                    </div>
                );
                }
            
            export default Notification;
    


    2. createContext 만들기 [store 폴더]

        ** "createContext" 는 "초기값만 만들고 빠지는거야!"
-           초기값을 제외한 모든 행동은 "ContextProvider" 함수에서 처리할거야!

        <프로세스>
            context 안에, notificationData 라는 껍데기를 만들고,
            showNotification 과 hideNotification 함수로, notificationData 를 조절하게 만들며,
            "바깥에서, notificationData 가 존재한다면 => 어떤일이 벌어진다". 로 로직을 짜면 깔끔!
            "모든곳에서 context 를 제어할 수 있으니까!"

            "이번 프로젝트에서는"
            "Contact Form"을 만지는 파일에서,
            api로부터, 값을 전달할때, [전달중], [완료 혹은 실패] 를 판단하여 
                적절한 값을, context 에 값을 집어넣어 사용하도록 할 것이다.


        <필수 로직>
-           데이터가 있을때만, 활성화시키게 하기 [삼항식, &&식 이용하여 가능]


        <코드> 
        ===========  < createContext > : "store/ contact-context"  ===========================================================================

            import { createContext, useState } from "react";

            const NotificationContext = createContext({
                notificationData: {}, //title,message,status
                showNotification: function () {},
                hideNotification: function () {},
            });

            export function NotificationContextProvider(props) {
                const [notificationData, setNotificationData] = useState();

                function showNotificationHandler(notificationData) {
                    setNotificationData(notificationData);
                }

                function hideNotificationHandler() {
                    setNotificationData(null);
                }

                const context = {
                    notificationData: notificationData,
                    showNotification: showNotificationHandler,
                    hideNotification: hideNotificationHandler,
                };
                return (
                    <NotificationContext.Provider value={context}>
                        {props.children}
                    </NotificationContext.Provider>
                );
                }

            export default NotificationContext;


    3. context 사용하기 [contact form 에서 API 와 통신할때] , [ Notification component 에서, notification 종료할때] 


        import { useRef, useContext } from "react";
-       import NotificationContext from "../../store/contact-context";      // context 사용하기위한 import
                ...

-       import Notification from "../ui/notification";                      // notification component 불러오기

        function ContactForm() {
        const emailRef = useRef();
        const nameRef = useRef();
        const contentRef = useRef();

-       const NotificationCtx = useContext(NotificationContext);            // context 사용
-       const activeNotification = NotificationCtx.notificationData;        // context 안에 있는 Data 에 접근

        function submitHandler(event) {
            event.preventDefault();

            const insertData = {
                email: emailRef.current.value,
                name: nameRef.current.value,
                content: contentRef.current.value,
            };

-           NotificationCtx.showNotification({                              // Context Data 에 접근하여, 값 집어넣기
                title: "audtlr",
                message: "pending",
                status: "pending",
            });

            fetch("/api/contact-api", {
                method: "POST",
                body: JSON.stringify(insertData),
                headers: {
                    "Content-Type": "application/json",
                },
            })
-           .then((res) => {                                                // 만약, res.ok 이면, 평소대로
                if (res.ok) {
-                   return res.json();                                      // 이 if문에서는, code 가 여기까지만 실행되어야 하니, return
                }
-               return res.json().then((data) => {                          // res.ok 가 아니라면, "새 프로미스 체인"을 만들어서, "에러발생시킴"
                    throw new Error(error || "you got a error");
                });
            })
-           .then(                                                          // 정상적인 if문을 통과했다면, "새 프로미스체인이 아니고", 지금 이 프로미스체인이 실행
                (data) => (
                console.log(data),
                NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "success",
                })
                )
            )
-           .catch((error) => {                                             // 에러가 발생되었다면, catch
                console.log(error);
                NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "error",
                    });
            });
        }

        return (
            <Fragment>
            <header className={styles.header}>
                <h1> CONTACT ME !</h1>
            </header>
            <main className={styles.main}>
                <form>
                <div>
                    <label htmlFor="email"> your email</label>
                    <input
                    type={"email"}
                    id={"email"}
                    
                    ...

            </main>
-           {activeNotification && <Notification />}                        // 만약, context안의 Data가 "있다면", Notification component를 렌더
            </Fragment>
        );
        }

        export default ContactForm;


16-1. "만약, 전체 여기저기 페이지가 아니라, 한 페이지에서만 사용할 것이라, Context 를 사용하지 않고, 일반적으로 구현한다면?" 

    ==> useState 를 사용하여, 똑같이 값이 있다면, 보이게 하게 만들고,
        props 로 값을 전달하면 되겠다.

16-2. 와!!!  ***********  [ [컴포넌트 함수 안]에  [만든 새로운 함수] 에서는, [fetch 사용할때, async await 를 사용해도 된다]!!!! ] *********

        
    function ContactForm() {
        const emailRef = useRef();
            ...

-       function submitHandler(event) {
            event.preventDefault();
    
-           fetch("/api/contact-api", {
                    ...

                .then((res) => {
                if (res.ok) {
                    return res.json();

                .then(
                (data) => (
                    console.log(data),
                    NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "success",
                    })
                )
                )
                .catch((error) => {
                console.log(error);
                NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "error",
                });
                });
            }

    ===>> "이런 긴 프로미스체인을 쓸 필요가 없고" [컴포넌트 함수] 의[안에 있는 함수] 이므로, "async, await 가 사용가능해져서"

        function ContactForm() {
            const emailRef = useRef();
                ...
        
-           async function submitHandler(event) {
                event.preventDefault();

-               const response = await fetch("/api/contact-api", {
                                ...


-   ===>> [ async await 를 사용할 수 있따.... ] ***************************

    < async await 을 사용하는 fetch 코드로 다시 변경시키면>

        async function submitHandler(event) {
            event.preventDefault();

            NotificationCtx.showNotification({
                title: "audtlr",
                message: "pending",
                status: "pending",
            })

            const response = await fetch("/api/contact-api", {
                method: "POST",
                body: JSON.stringify(insertData),
                headers: {
                    "Content-Type": "application/json",
                },
            })

            const data = await response.json()

            if(!response.ok){
                NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "success",
                })
            }else{
                NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "error",
                    status: "error",
                })
            }

    ==> "와... 진짜 깔끔해졌다."

17. [수정] useRef 가 아니라 , useState 를 사용하여, Form 의 INPUT 안에 값을 빼기 [ + useState 를 사용하는 장점]
    
    <장점>
        useRef 는, input 안의 값을 건들 수 없고, 받아 올 수만 있으므로, 빼오긴 좋지만, input값 컨트롤이 안됌
            반면 useState 는 컨트롤이 가능하다

    <사용> : onChange 를 사용하여, 콜백함수를 넣어준다.
        
        const [textState, setTextState] = useState()

        input type="text" value={textState} onChange={(event)= setTextState(event.target.value) }

    <코드>
        function ContactForm() {
            const [emailState, setEmailState] = useState();
            const [nameState, setNameState] = useState();
            const [contentState, setContentState] = useState();
        
            const NotificationCtx = useContext(NotificationContext);
            const activeNotification = NotificationCtx.notificationData;
        
            async function submitHandler(event) {
                event.preventDefault();
            
                const insertData = {
                    email: emailState,
                    name: nameState,
                    content: contentState,
                };
                    ...

                } else {
                    NotificationCtx.showNotification({
                    title: "audtlr",
                    message: "success",
                    status: "success",
                    });
-                   setEmailState("");                          // fetch 에 성공하면, 이렇게 input을 지울 수 있음
-                   setNameState("");
-                   setContentState("");
                }
                }

          return (
            <Fragment>
            <header className={styles.header}>
                <h1> CONTACT ME !</h1>
            </header>
            <main className={styles.main}>
                <form>
                <div>
                    <label htmlFor="email"> your email</label>
                    <input
                    type={"email"}
                    id={"email"}
                    name={"email"}
                    required
                    placeholder="input your email"
-                   value={emailState}                                 // value와 onChange 를 통해서, useRef 처럼 값을 받아옴
-                   onChange={(e) => setEmailState(e.target.value)}

18. [수정한것들]

    1. 카테고리 페이지 만들기
    2. 카테고리 분류해서, 따로만들었음
    3. 이것저것 스타일링

19. 배포를 위한 metadata head 추가하기

    1) 전체 페이지에 추가할 MetaData => "_app.js" 에서 Head 태그로 생성 [ 대부분 viewport 생성 ]

            import Head from "next/head";

            function MyApp({ Component, pageProps }) {
            return (
                <NotificationContextProvider>
-               <Head>
-                   <meta name="viewport" content="width=device-width, initial-scale=1" />
-               </Head>
                <Layout>
                    <Component {...pageProps} />
                </Layout>
                </NotificationContextProvider>
            );
            }

            export default MyApp;

    2) 각각 페이지에 대한 MetaData => "각각의 페이지마다 Head 를 만들어 생성" [title, description 이 보통]

-           import Head from "next/head";

            function HomePage(props) {
                const { posts } = props;
                return (
                    <div>
-                   <Head>
-                       <title> Ms React Blog</title>
-                       <meta name="description" content="i Post my study for react and javascript"/>
-                   </Head>
                    <div>
                        <Welcome />
                        <FeacturePosts posts={posts} />
                    </div>
                    </div>
                );
                }

    3) 동적 페이지에 대한 MetaData => "동적인 값으로" MetaData 안에 값을 넣는다.

            import Head from "next/head";

            function PostDetailPage(props) {
                const { postData } = props;
                return (
                    <div>
-                   <Head>
-                       <title> {postData.title}</title>
-                       <meta name="description" content={postData.description}></meta>
-                   </Head>
                    <PostContent posts={postData} />
                    </div>
                );
            }
                    

20. _document.js 파일 추가하여, [전체 앱을 감싸 바깥에서 컨트롤하기] + React Portal 사용준비

    <  _document.js 의 기본 형태  >
        
            import Document, { Html, Head, Main, NextScript } from "next/document";

            class MyDocument extends Document {

            render() {
                return (
                <Html>
                    <Head />
                    <body>
                        <Main />
                        <NextScript />
                    </body>
                </Html>
                );
            }}

            export default MyDocument;

    => <Html lang="en"> 처럼 이것저것 바깥에서 추가 할 수 있음


21. React Portal
    
    React 에서, 대부분 부모로부터, "인접한", 자식노드에게만 데이터와 컴포넌트를 전달한다.

    그렇지만, 가끔, 전혀 상관없는 노드로부터 컴포넌트를 받아야 될 때가 있다.

    마치 어디서든 튀어나오는 팝업 창 같은 것들이 대표적이다.

    "React Portal 은 DOM 의 다른 위치에 자식을 삽입하는 것을 가능하게 만들어준다."


    1) < _document.js 에, Portal 로 삽입할 위치를 정한다. >

            import Document, { Html, Head, Main, NextScript } from "next/document";

            class MyDocument extends Document {

            render() {
                return (
                <Html>
                    <Head />
                    <body>
                        <Main />
                        <NextScript />
-                       <div id="notification"></div>       // 이곳(Next.js의 컴포넌트가 전부 렌더링 된 다음곳)에 , 만든 Portal 을 삽입할것이다.
                    </body>
                </Html>
                );
            }}

            export default MyDocument;

    2) 기존에 만들어둔 "컴포넌트" 를, "Portal 로 만들어준다."

        < 기본사용 >

            1) Portal 생성 : ReactDOM.createPortal

                import ReactDOM from "react-dom"

                [기본]
                    ReactDOM((children), 위치)

                [디테일]
                    ReactDOM((children), document.getElementById(""))

                [실제사용]

-                   return ReactDOM.createPortal((
                        <div>
                            hi
                        </div>
-                   ), document.getElementById("notification") );

            2) Portal 위치 : "_document.js 에서 <body> 태그 어디든"



        < 기존 >

            import styles from "./notification.module.css";

            function Notification() {
                    ...


            return (
                <div className={styles.notification} onClick={hideNoti}>
                    <ul className={statusStyle}>
                        <li>{activeNotification.title}</li>
                        <li>{activeNotification.message}</li>
                        <li>{activeNotification.status}</li>
                    </ul>
                </div>
            );
            }

            export default Notification;

        < 변경 >
            : "react-dom" 으로부터 ReactDOM 을 추출해, "return된 컴포넌트를 감싸고", "두번째 인수에, 위치를 getElementById 로 추가"한다.

-           import ReactDOM from "react-dom"
            import styles from "./notification.module.css";

            function Notification() {
                    ...


-           return ReactDOM.createPortal((
                <div className={styles.notification} onClick={hideNoti}>
                    <ul className={statusStyle}>
                        <li>{activeNotification.title}</li>
                        <li>{activeNotification.message}</li>
                        <li>{activeNotification.status}</li>
                    </ul>
                </div>
-           ), document.getElementById("notification") );
            }

            export default Notification;


22.  Next js의 배포 방법의 두가지 [ standard Build, Full Static Build ]

    1) "standard Build"
        : 가장 기본적인 Build 로, npm run build 할때, 그 빌드이다.

        : 모든 Nextjs 의 기능(자동 validate, serverside code 등...)을 전부 활용 하여 Build 하는 방법이자,
            가장 기본적이고, 충실한 Build 방법이다.

        : getStaticProps, getServerSideProps 를 비롯한 API 등까지 전부 사용 가능하다.

    2) "Full Static Build"
        : 완벽하게, 정적인 포지션의 Build

        : getStaticProps, getServerSideProps 를 비롯한 API 등의 "모든 서버측 코드가 사용 불가능하다"

        :" 완벽히 정적인" "HTML, CSS, JAVASCRIPT 만을 사용해 만든 사이트만"이, 이 BUILD 방법으로, 배포가 가능하다


23. 배포의 준비

    1) 코드를 재정비

        : MetaData, title, 등을 확인하고,
            console.log 들도 지워버리고,
            필요없는 dependencies 도 지워버린다.

    2) 환경변수를 확인 ***

        : 특히나, "MONGODB" 나 "API KEY, 주소들" 을, "환경변수 처리"하거나, 하드코딩 되어있는 것들을 잘 확인하여, 배포해야한다.

    3) 배포하기전, 빌드된 파일을 테스트

        : 빌드후 나오는 로컬서버로, 테스트를 한다.

    4) 배포한다!


24. 환경변수  [next.config.js 안에서 설정]

    [nextjs DOCs]
        https://nextjs.org/docs/api-reference/next.config.js/environment-variables

            <기본 생성>
                module.exports = {
                    env: {
                    customKey: 'my-value',
                    },
                }

            <기본 사용> : "어디에서든 사용가능"
                function Page() {
                    return <h1>The value of customKey is: {process.env.customKey}</h1>
                }
                
                export default Page

        ==> 기타등등의 설정들도, next js 의 DOCS 에 가면 볼 수있다.


    <환경변수의 목적> **** ***

        : 

    <환경변수 실제 사용>

        < next.config.js > : "환경변수 생성"

            /** @type {import('next').NextConfig} */
            const nextConfig = {
                reactStrictMode: true,
            };

            module.exports = nextConfig;

            module.exports = {
-               env: {
                    mongodb_username: "audtlr",
                    mongodb_password: "nxhYrEZyYpajzBBY",
                    mongodb_clustername: "cluster0",
                    mongodb_database: "BlogContact",
                },
            };

        
        < db-util > : "하드코딩 된 것을 환경변수로 교체"

            import { MongoClient } from "mongodb";

-           const MongodbURI = `mongodb+srv://${process.env.mongodb_username}:${process.env.mongodb_password}@${process.env.mongodb_clustername}.mzdaqy1.mongodb.net/?retryWrites=true&w=majority`;

            export function ConnectMongodb() {
                const client = new MongoClient(MongodbURI);
            return client;
            }

            export async function insertUserInfo(client, collection, data) {
            return client
-               .db(`${process.env.mongodb_database}`)
                .collection(collection)
                .insertOne(data);
            }


25. 그래서 환경변수를 왜 사용하는가?

    0) API 라우트 안의, API 주소, MONGODB 주소, 아이디 등 ... 
        "배포할때"나, 어떤 코드를 입력할때, "동적으로",  그것들을 변경가능하게 만들어준다.

    1) "개발단계"와" 배포단계"에 "서로 다른 값을 넣어주어" 조건에 맞는 단계를 실행 시킬 수 있다.
        
        예를들어, mongoshell(로컬 mongodb 서버) 을 사용하여, 개발을 하다가
            , 배포단계 에서는 mongodb Atlas(클라우드 mongodb 서버) 를 사용할 수 있다.

        "각각의 서버 주소가 다르기에, 환경변수를 사용하여, 각 단계별 다른 주소를 사용 할 수 있다."

    2) 배포시에는, 환경변수를 입력하여, 자동으로 그 환경변수로 Deploy 해주는 호스팅 사이트가 있다.
        [heroku] 에 배포햇을때, ENV.CONFIG 에 입력했다.

-       "그런 호스팅 사이트가 아니라도, 내가 직접, 개발단계, 배포단계마다 다른 환경변수를 넣을 수 있게 되는것이다."


26. 환경변수에, 내가 어떤 단계인지 전달하기 (개발, 배포, EXPORT로 배포, 서버가동중)

    1) "단계" import 하기
        "nextjs.config" 에서, "node js"처럼 "개발단계" 를 불러온다. (import 가 아니라, require)

        const { PHASE_DEVELOPMENT_SERVER } = require("next/constants");
                { PHASE_PRODUCTION_BUILD }
                { PHASE_PRODUCTION_SERVER }
                { PHASE_EXPORT}

        등이 있따.

        PHASE_DEVELOPMENT_SERVER    :   개발단계
        PHASE_PRODUCTION_BUILD      :   빌드단계
        PHASE_PRODUCTION_SERVER     :   서버 가동중
        PHASE_EXPORT                :   epxort 로 정적사이트 배포단계

    2) module.exports 를 할때, "함수형" 으로 만들어서 "if문을 사용 가능하게" 만들어, "단계별 다른 환경변수를 넣어준다."

        < nextjs.config >

-           const { PHASE_DEVELOPMENT_SERVER } = require("next/constants");

            /** @type {import('next').NextConfig} */
            const nextConfig = {
            reactStrictMode: true,
            };

            module.exports = nextConfig;

-           module.exports = (phase) => {
-           if (phase === PHASE_DEVELOPMENT_SERVER) {
                return {
                env: {
                    mongodb_username: "audtlr",
                    mongodb_password: "nxhYrEZyYpajzBBY",
                    mongodb_clustername: "cluster0",
                    mongodb_database: "BlogContact-dev",
                },
                };
            }
-           return {
                env: {
                mongodb_username: "audtlr",
                mongodb_password: "nxhYrEZyYpajzBBY",
                mongodb_clustername: "cluster0",
                mongodb_database: "BlogContact",
                },
            };
            };

        ==> "개발단계"       에는 "database" 를 "BlogContact-dev"
            "그 이외의 단계" 에는 "database"를  "BlogContact" 


27.  dev 서버에서 확인은 끝났다. 이제 build 를 해서 확인하려, build를 햇는데, 용량이 너무 큰게 있다.

        c699cb87ce0e0da0.css                    488 B
        ├   └ /category/nextjs (498 ms)
        ├ ○ /contact (369 ms)                             1.42 kB          80 kB
        ├   └ css/e2d8d81e1bc39e7a.css                    630 B
        ├ ● /posts (496 ms)                               845 B          79.4 kB
        ├   └ css/797ed8d953f37242.css                    536 B
-       └ ● /posts/[postid] (ISR: 500 Seconds) (5733 ms)  272 kB          350 kB
            └ css/1c165c261101802e.css                    436 B
            ├ /posts/mastering-javascript (1919 ms)

    ==> 빌드 후, 로그창에, "빨간색으로, 용량이 너무 큰 파일이 있다."

        잘못된 것은 아니지만, 좋은 것도 아니다.

    ** 저 용량의 크기는 "클라이언트 사이드가 불러올 크기를 말하는 것이므로, 서버측 코드는 상관없다."
        (용량을 줄이기 위해, getStaticProps 나, getServerSideProps 를 볼 필요는 없다는 말이다.)

28. 용량 문제 해결 - /posts/[postid]

    ==> 들어가면 "코드 보다는 타사패키지가 문제인 경우가 대부분이다."

    ==> 우리의 문제는 [postid]에 import 되어있는" post-content 컴포넌트" 안의 "react-syntax-highlighter 패키지" 용량이 너무 큰 것이다.

    ==> "react-syntax-highlighter" 를, Light 버젼으로 적용시켜준다.
            * 방법은 "react-syntax-highlighter npm page"에 나와있음 


        <방법 - npm>
            import { PrismLight as SyntaxHighlighter } from 'react-syntax-highlighter';
            import jsx from 'react-syntax-highlighter/dist/cjs/languages/prism/jsx';
            import prism from 'react-syntax-highlighter/dist/cjs/styles/prism/prism';

            SyntaxHighlighter.registerLanguage('jsx', jsx);


-       < 적용 >  : "Light 테마를 가져오고", "색을 단 한개만 임포트", "언어도 전부 아니고 하나씩 따로 임포트" 후 등록해줌

            import { PrismLight as SyntaxHighlighter } from "react-syntax-highlighter";
            import dark from "react-syntax-highlighter/dist/cjs/styles/prism/dark";

            import js from "react-syntax-highlighter/dist/cjs/languages/prism/javascript";
            import css from "react-syntax-highlighter/dist/cjs/languages/prism/css";

            SyntaxHighlighter.registerLanguage("js", js);
            SyntaxHighlighter.registerLanguage("css", css);

    ===> "다시 build 하면 용량이 줄어든다."


-   ** 다시말하지만 "esm" 은 로컬용이다.    반드시 "cjs" 로 변경해주도록 하자

    < 변경완료 후 build >

        ├ ● /posts (444 ms)                               845 B          79.4 kB
        ├   └ css/797ed8d953f37242.css                    536 B
-       └ ● /posts/[postid] (ISR: 500 Seconds) (4944 ms)  49.7 kB         128 kB
        └ css/1c165c261101802e.css                    436 B
        ├ /posts/mastering-javascript (1672 ms)
        ├ /posts/getting-start-with-nextjs (1637 ms)
        └ /posts/getting-start-with-react (1635 ms)

        ==> 가벼워졌다.


29. build 하면서 고친점

    < next/legacy/image >
        
        1) next13에 오면서 <Image> 가 바뀌었다. 
            이젠, "next/legacy/image" 로 불러와야한다. import Image from "next/legacy/image"

        2) "이미지 용량이 너무 크면" "priority" 를 적용한다. ***

        3) "leagcy"로 넘어오면서 "자체적인 width 와 height" 적용이 가능하니, css에서는 auto 를 적용해도 괜찮다.

30. build 한것 확인 => npm start 로, 프로덕션용 앱 실행!

    : 실행 잘되는것 확인

    "우와 짱빨러.. 진짜... 최고네;;"

31. Vercel 을 이용한 Nextjs 배포!

    Vercel 은 nextjs 를 만든 회사의 것으로, Nextjs 를 배포하기 아주 좋은 환경을 가지고있다!

    https://vercel.com/pricing

    <프로세스>

        1. GITHUB 나 어떠한 저장소에, 코드 push

        2. vercel 에 접속해, 저장소에 저장된 코드 배포

            끝!

    <준비>

        1. git, github 아이디, 프로그램

        2. vercel 아이디 - github 아이디로 로그인하면됌

    <디테일>

        1. git 프로그램 다운

        2. git 실행 후, commit

        3. github repository 만들어서 push

        3-1. <만약 처음이라면>  Github의 Personal Acess Token 을 설정하고, 꼭 내 컴퓨터에 복사해두고 사용할것

        4. Vercel 에서 Github 로 배포






    
                    


